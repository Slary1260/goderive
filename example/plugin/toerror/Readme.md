The deriveToError function is useful for composing bool-returning functions along with traditional error-returning functions.

Given the following input:

```go
package toerror

import (
	"fmt"
	"net/http"
)

func parseMajorHTTPVersion(versionString string) (int, error) {
	return deriveCompose(
		deriveToError(fmt.Errorf("HTTP version parsing failed."), http.ParseHTTPVersion),
		func(major, minor int) (int, error) {
			return major, nil
		},
	)(versionString)
}
```

goderive will generate the following code:

```go
// Code generated by goderive DO NOT EDIT.

package toerror

// deriveToError transforms sum-bool type into sum-error type. Main purpose is to make the given function composable. It returns given error when the result of the function is false.
func deriveToError(err error, f func(vers string) (major int, minor int, ok bool)) func(vers string) (int, int, error) {
	return func(vers string) (int, int, error) {
		out0, out1, success := f(vers)
		if success {
			return out0, out1, nil
		}
		return out0, out1, err
	}
}

// deriveCompose composes functions f0 and f1 into one function, that takes the parameters from f0 and returns the results from f1.
func deriveCompose(f0 func(string) (int, int, error), f1 func(int, int) (int, error)) func(string) (int, error) {
	return func(v_0_0 string) (int, error) {
		v_1_0, v_1_1, err0 := f0(v_0_0)
		if err0 != nil {
			return 0, err0
		}
		v_2_0, err1 := f1(v_1_0, v_1_1)
		if err1 != nil {
			return 0, err1
		}
		return v_2_0, nil
	}
}
```
